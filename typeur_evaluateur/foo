[H[2J[3J[0;32mCleaning project[0m 
[0;32mRunning test[0m 
[0;32mRunning project[0m 
INFERENCE DE TYPE
sur les let
(let x = 1 in (x + 3))
(let x = 1 in (x + 3)) ***TYPABLE*** avec le type Nat
4

(Î»T62 -> T62)
(let x = 4 in (Î»x -> x)) ***TYPABLE*** avec le type (T65 -> T65)
(Î»T67 -> T67)

[1; 3; 4]
[1; 3; 4] ***TYPABLE*** avec le type Nat PList

[1; 3; [2]]
[1; 3; [2]] ***PAS TYPABLE*** : type entier non-unifiable avec T75 PList

(let x = 4 in (Î»y -> x))
(let x = 4 in (Î»y -> x)) ***TYPABLE*** avec le type (T79 -> Nat)
(Î»T82 -> 4)

(if 1 then 1 else 2)
(if 1 then 1 else 2) ***TYPABLE*** avec le type Nat
1

(if [1] then 1 else 2)
(if [1] then 1 else 2) ***TYPABLE*** avec le type Nat
1

(Î»x -> (let y = (x + 1) in (x y)))
(Î»x -> (let y = (x + 1) in (x y))) ***PAS TYPABLE*** : type fleche non-unifiable avec Nat

(Î»x -> (let y = x in (x y)))
(Î»x -> (let y = x in (x y))) ***PAS TYPABLE*** : occurence de T93 dans (T93 -> T91)

(Î»x -> (let y = x in (y x)))
(Î»x -> (let y = x in (y x))) ***PAS TYPABLE*** : occurence de T97 dans (T97 -> T95)

(let x = (ref 2) in (x := 3))
(let x = (ref 2) in (x := 3)) ***PAS TYPABLE*** : type entier non-unifiable avec ref Nat

(Î»x -> (x := (!x + 1)))
(Î»x -> (x := (!x + 1))) ***TYPABLE*** avec le type (Nat -> unit)

(let x = (ref 3) in x)
(let x = (ref 3) in x) ***TYPABLE*** avec le type ref Nat

(let f = (Î»x -> (x := (!x + 3))) in (f 2))
(let f = (Î»x -> (x := (!x + 3))) in (f 2)) ***TYPABLE*** avec le type unit

