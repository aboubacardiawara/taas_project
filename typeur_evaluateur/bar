[H[2J[3J[0;32mCleaning project[0m 
[0;32mRunning test[0m 
[0;32mRunning project[0m 
inference2 DE TYPE
sur les let
(let x = 1 in (x + 3))
(let x = 1 in (x + 3)) ***TYPABLE*** avec le type Nat
4

(Î»T63 -> T63)
(let x = 4 in (Î»x -> x)) ***TYPABLE*** avec le type (T68 -> T68)
(Î»T70 -> T70)

[1; 3; 4]
[1; 3; 4] ***TYPABLE*** avec le type Nat PList

[1; 3; [2]]
[1; 3; [2]] ***PAS TYPABLE*** : type entier non-unifiable avec T78 PList

(let x = 4 in (Î»y -> x))
(let x = 4 in (Î»y -> x)) ***TYPABLE*** avec le type (T84 -> Nat)
(Î»T87 -> 4)

(if 1 then 1 else 2)
(if 1 then 1 else 2) ***TYPABLE*** avec le type Nat
1

(if [1] then 1 else 2)
(if [1] then 1 else 2) ***TYPABLE*** avec le type Nat
1

(Î»x -> (let y = (x + 1) in (x y)))
(Î»x -> (let y = (x + 1) in (x y))) ***PAS TYPABLE*** : type fleche non-unifiable avec Nat

(Î»x -> (let y = x in (x y)))
(Î»x -> (let y = x in (x y))) ***PAS TYPABLE*** : occurence de T102 dans (T102 -> T100)

(Î»x -> (let y = x in (y x)))
(Î»x -> (let y = x in (y x))) ***PAS TYPABLE*** : occurence de T108 dans (T108 -> T106)

(let x = (ref 2) in (x := 3))
(let x = (ref 2) in (x := 3)) ***PAS TYPABLE*** : type entier non-unifiable avec ref Nat

(Î»x -> (x := (!x + 1)))
(Î»x -> (x := (!x + 1))) ***TYPABLE*** avec le type (Nat -> unit)

(let x = (ref 3) in x)
(let x = (ref 3) in x) ***TYPABLE*** avec le type ref Nat

(let f = (Î»x -> (x := (!x + 3))) in (f 2))
(let f = (Î»x -> (x := (!x + 3))) in (f 2)) ***TYPABLE*** avec le type unit

